#include <stdio.h>
#include <stdlib.h>

#include "mpi.h"

// argc - количество аргументов командной строки
// argv - массив строк (сами аргументы)
int main(int argc, char *argv[]) {

    
    int ProcRank; // Переменная для хранения ранга (уникального ID) текущего процесса
    int ProcNum;  // Переменная для хранения общего количества запущенных процессов
    int RecvRank; // Вспомогательная переменная для процесса 0 (чтобы сохранить ранг, полученный от другого)
    
    int n = 0; // Размер задачи (будет считан из аргументов командной строки)
    
    // Структура для хранения информации о статусе полученного сообщения (от кого, какой тег и т.д.)
    // Обязательно передается в MPI_Recv
    MPI_Status Status; 
    
    // Переменные для замера времени выполнения
    double start_time, end_time; 

    
    // Инициализирует среду MPI. Должна вызываться самой первой из MPI-функций.
    MPI_Init(&argc, &argv); 
    
    // Получает общее количество процессов в коммуникаторе MPI_COMM_WORLD (т.е. всех)
    // и записывает это число в переменную ProcNum.
    MPI_Comm_size(MPI_COMM_WORLD, &ProcNum); 
    
    // Получает ранг (ID) текущего процесса (от 0 до ProcNum-1)
    // и записывает его в переменную ProcRank.
    MPI_Comm_rank(MPI_COMM_WORLD, &ProcRank); 

    
    // Только "главный" процесс (с рангом 0) будет считывать аргументы.
    if (ProcRank == 0) {
        // Проверяем, был ли передан аргумент. argc < 2 означает, что передано только имя программы.
        if (argc < 2) {
            // Если 'n' не указан, выводим предупреждение и используем n=0
            fprintf(stderr, "Предупреждение: Размер задачи 'n' не указан. Используется n=0.\n");
            n = 0;
        } else {
            // Если аргумент есть, конвертируем его из строки (argv[1]) в целое число (int)
            n = atoi(argv[1]);
            // Проверяем, что 'n' положительное
            if (n <= 0) {
                fprintf(stderr, "Ошибка: Размер задачи 'n' должен быть положительным числом.\n");
                // Устанавливаем n = -1 как флаг ошибки
                n = -1; 
            }
        }
    }
    
    /* * КОЛЛЕКТИВНАЯ ОПЕРАЦИЯ: "Широковещательная рассылка" (Broadcast)
     * 1. Процесс 0  берет значение из своей переменной 'n'.
     * 2. Он отправляет это значение всем остальным процессам.
     * 3. Все остальные процессы (1, 2, 3...) принимают это значение и записывают в свою переменную 'n'.
     * (&n, 1, MPI_INT) - адрес данных, количество, тип
     * (0, MPI_COMM_WORLD) - ранг отправителя (root), коммуникатор
     */
    MPI_Bcast(&n, 1, MPI_INT, 0, MPI_COMM_WORLD);
    
    // Теперь ВСЕ процессы (не только 0) проверяют флаг ошибки (необходимо для корректного и синхронного заврешения работы если данные некорректны).
    if (n == -1) {
        MPI_Finalize(); // Корректно завершаем MPI
        return 1;       // Выходим из программы с кодом ошибки
    }
    
    /* * КОЛЛЕКТИВНАЯ ОПЕРАЦИЯ: "Барьер"
     * Все процессы "зависают" на этой строке, пока КАЖДЫЙ из них до нее не дойдет.
     * Это нужно, чтобы все процессы начали замер времени одновременно.
     */
    MPI_Barrier(MPI_COMM_WORLD); 
    
    // Каждый процесс засекает свое локальное время (в секундах)
    start_time = MPI_Wtime(); 

    
    // Логика делится: что делает процесс 0 и что делают все остальные.
    if (ProcRank == 0) {
        // Процесс 0 сначала печатает "Hello" от себя
        printf("Hello from process %3d\n", ProcRank);
        
        // Затем он входит в цикл, чтобы получить (ProcNum - 1) сообщений
        // (по одному от каждого другого процесса)
        for (int i = 1; i < ProcNum; i++) {
            /* * ОПЕРАЦИЯ "ПРИЕМ": Процесс 0 блокируется (ждет)
             * &RecvRank - буфер, куда положить принятые данные (ранг)
             * 1, MPI_INT - ожидаемое кол-во и тип данных
             * MPI_ANY_SOURCE - ВАЖНО: принять от ЛЮБОГО источника (не ждать по порядку 1, 2, 3...)
             * 0 - ожидаемый тег сообщения
             * MPI_COMM_WORLD - коммуникатор
             * &Status - структура, куда запишется информация (от кого реально пришло)
             */
            MPI_Recv(&RecvRank, 1, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &Status);
            
            // Печатаем ранг, который мы ФАКТИЧЕСКИ получили
            printf("Hello from process %3d\n", RecvRank);
        }
    } else {
        // Этот код выполняют ВСЕ ОСТАЛЬНЫЕ процессы (1, 2, 3...)
        /*
         * ОПЕРАЦИЯ "ОТПРАВКА":
         * &ProcRank - адрес данных для отправки (отправляем свой ранг)
         * 1, MPI_INT - кол-во и тип данных
         * 0 - ранг получателя (отправляем процессу 0)
         * 0 - тег сообщения
         * MPI_COMM_WORLD - коммуникатор
         */
        MPI_Send(&ProcRank, 1, MPI_INT, 0, 0, MPI_COMM_WORLD);
    }

    // --- 5. ОКОНЧАНИЕ ЗАМЕРА ВРЕМЕНИ ---
    
    // Снова ставим барьер, чтобы процесс 0 не закончил замер времени
    // раньше, чем все остальные процессы отправят ему сообщения.
    MPI_Barrier(MPI_COMM_WORLD); 
    
    // Каждый процесс фиксирует свое локальное время окончания
    end_time = MPI_Wtime(); 
    
    // Только процесс 0 выводит итоговое время
    if (ProcRank == 0) {
        // Считаем разницу (на машине процесса 0) и выводим
        printf("\nTotal execution time for n=%d: %f seconds\n", n, end_time - start_time);
    }

    
    // Корректно завершаем работу MPI. Обязательная функция.
    MPI_Finalize(); 
    
    // Все процессы успешно завершают работу
    return 0; 
}
